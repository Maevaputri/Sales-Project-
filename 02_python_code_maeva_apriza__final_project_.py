# -*- coding: utf-8 -*-
"""02_Python code_Maeva Apriza__Final_Project_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TfmFtYOjdf_JXhx1I5hfRlB1QAtFSqku

# 1. IMPORT LIBRARY & DATA
"""

# ==============================
#IMPORT DATA PROCESS
# ==============================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import missingno as msno
from datetime import datetime
from sklearn.preprocessing import LabelEncoder


# Load dataset
df = pd.read_csv('/content/Ecommerce_Consumer_Behavior_Analysis_Data.csv')
df.head()

"""# Data Understanding

This stage is used to understand the overall structure of the dataset, such as data types, category distribution, and minimum-maximum values ​​in numeric columns. This is important for detecting early anomalies, such as outliers or irrelevant categories.
"""

# Struktur data
df.info()

# Summary statistics
df.describe(include='all')

# Initial distribution of some categorical features
for col in ['Gender', 'Income_Level', 'Marital_Status', 'Purchase_Channel', 'Customer_Loyalty_Program_Member']:
    print(f"\nDistribusi kategori kolom: {col}")
    print(df[col].value_counts(normalize=True) * 100)

"""#Cleaning Data

Data cleaning ensures that data types are correct, missing values ​​are handled, and text formats such as dollars or dates are changed so that Python can process them numerically and analytically.
"""

# Ubah kolom nominal
df['Purchase_Amount'] = df['Purchase_Amount'].replace('[\$,]', '', regex=True).astype(float)

df['Purchase_Amount'].head()

# Convert time to datetime
df['Time_of_Purchase'] = pd.to_datetime(df['Time_of_Purchase'])

df['Time_of_Purchase'].head()

# Replace None with NaN
df.replace('None', np.nan, inplace=True)

# Drop rows
df.dropna(subset=['Purchase_Amount', 'Brand_Loyalty', 'Product_Rating'], inplace=True)

# Check missing values
print(df.isnull().sum())

# Handling
df['Social_Media_Influence'] = df['Social_Media_Influence'].fillna(df['Social_Media_Influence'].mode()[0])
df['Engagement_with_Ads'] = df['Engagement_with_Ads'].fillna(df['Engagement_with_Ads'].mode()[0])

df.isnull().sum()

# Standardize gender
df['Gender'] = df['Gender'].apply(lambda x: x if x in ['Female', 'Male'] else 'Prefer not to say')

df['Gender'].head()

"""# 3. FEATURE ENGINEERING

Several important transformations were performed:

Extracting Month_of_Purchase from date

Encoding categorical variables (Gender, Income_Level, Purchase_Channel, etc.)
"""

# New time-based columns
df['Month_of_Purchase'] = df['Time_of_Purchase'].dt.month
df['Day_of_Week'] = df['Time_of_Purchase'].dt.day_name()
df['Is_Weekend'] = df['Day_of_Week'].isin(['Saturday', 'Sunday'])

print(df[['Time_of_Purchase', 'Month_of_Purchase', 'Day_of_Week', 'Is_Weekend']].head())

# Extract month and hour from purchase time
df['Purchase_Month'] = df['Time_of_Purchase'].dt.month
df['Purchase_Hour'] = df['Time_of_Purchase'].dt.hour

"""# **EDA **
Only selected visualizations will be included in the presentation. The remaining visualizations serve as supporting materials for more in-depth analysis.

# I) CUSTOMER DEMOGRAPHICS & PROFILE

#1. Age Distribution

The goal of this visualization is to understand the age distribution of customers. This helps identify which age groups are most represented and supports targeted marketing or segmentation efforts.
"""

bins = [0, 19, 39, 59, 100] #membagi nilai ke rentang group dibawah
labels = ['<20', '20-39', '40-50', '59-60+']
df['Age_Group'] = pd.cut(df['Age'], bins=bins, labels=labels, right=True)

sns.countplot(data=df, x='Age_Group', palette='pastel')
plt.title("Age distribution by the range")
plt.xlabel("Age group")
plt.ylabel("amount of viito")
plt.tight_layout()
plt.show()

"""The chart shows that customer ages range from around 18 to 50 years old, with a relatively even spread. There are slight **peaks in the mid-20s, mid-30s, and mid-40s**, indicating clusters of customers in those age ranges.

# 2.Gender vs Purchasing

The purpose of this chart is to explore whether there are noticeable differences in purchase behavior based on gender. Specifically, it aims to see if any gender group tends to make higher-value purchases than others.
"""

sns.boxplot(data=df, x='Gender', y='Purchase_Amount')
plt.title("Purchase Value by Gender")
plt.show()

"""From the boxplot, all gender groups show similar purchase value ranges and medians, indicating no significant difference in purchase behavior between males, females, and those who prefer not to say. This suggests that **gender may not be a strong factor influencing purchase amounts** in this dataset.

#3. Income vs Loyality

To examine whether customers with higher income levels tend to show greater loyalty to a brand. This helps identify which income segment is more suitable for loyalty program targeting marketing.
"""

sns.boxplot(data=df, x='Income_Level', y='Brand_Loyalty')
plt.title("Brand Loyalty Based on Income")
plt.show()

"""The boxplot shows that both middle- and high-income groups have a similar spread and median of brand loyalty. There’s no clear distinction between the two groups, indicating that **income level may not be a strong predictor of brand loyalty** in this dataset. Loyalty appears to be distributed evenly regardless of income.

#4. Segmentation

To understand how customers are distributed across different value-based segments (Low, Medium, High, Very High) in order to support strategic marketing and prioritization
"""

#EDA HO GROUPBY CEK YAA

customer_spending = df.groupby('Customer_ID')['Purchase_Amount'].sum().reset_index()


print(customer_spending['Purchase_Amount'].describe())


bins = [0, 150, 300, 450, customer_spending['Purchase_Amount'].max() + 1]
labels = ['Low', 'Medium', 'High', 'Very High']


customer_spending['Segment'] = pd.cut(customer_spending['Purchase_Amount'],
                                      bins=bins,
                                      labels=labels,
                                      include_lowest=True)

if 'Segment' in df.columns:
    df = df.drop(columns=['Segment'])

df = df.merge(customer_spending[['Customer_ID', 'Segment']], on='Customer_ID', how='left')

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(8, 5))
sns.countplot(data=df.drop_duplicates(subset='Customer_ID'), x='Segment', palette='pastel')
plt.title('Distribution of Potential Customer Segments')
plt.xlabel('Segment')
plt.ylabel('Number of Customers')
plt.tight_layout()
plt.show()

"""Most customers fall into the **High and Medium segments, indicating they contribute significantly to overall business value.
The Very High segment is the smallest, but likely represents the most profitable customers**.

#II) PURCHASING BEHAVIOR & TRENDS

# f. Number of Purchases Per Day

To identify which days of the week customers are most active in making purchases, helping businesses optimize promotional timing.
"""

sns.countplot(data=df, x='Day_of_Week', order=['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'])
plt.title("Purchase Frequency per Day")
plt.xticks(rotation=45)
plt.show()

"""Purchases **peak on Tuesday, Sunday, and Thursday, while Wednesday and Saturday see the lowest activity**. This suggests that **promotions or campaigns may be most effective when scheduled for early and end-of-week** periods, particularly Tuesday and Sunday.

#Monthly Trends

To analyze monthly purchasing trends and identify periods of peak customer activity, enabling more effective planning for marketing or inventory.
"""

# Trend of purchases by month
df['Purchase_Month'] = df['Time_of_Purchase'].dt.month
monthly_sales = df['Purchase_Month'].value_counts().sort_index()

plt.figure(figsize=(8, 5))
monthly_sales.plot(kind='bar')
plt.title('Monthly Purchase Volume')
plt.xlabel('Month')
plt.ylabel('Number of Purchases')
plt.xticks(rotation=0)
plt.grid(axis='y')
plt.tight_layout()
plt.show()


print(" Highest purchase activity occurred in:", monthly_sales.idxmax())

"""**The highest purchase activity occurred in Month 6**, followed closely by Months 5 and 8. Meanwhile, **Month 12 recorded the lowest purchase volume**.

#Purchases monthly per channel

To compare monthly purchase trends across different channels InStore, Online, and Mixed, in order to understand customer preferences and optimize channel specific strategies.
"""

monthly_by_channel = df.groupby(['Purchase_Month', 'Purchase_Channel']).size().unstack()
monthly_by_channel.plot(kind='bar', figsize=(10, 5))
plt.title('Monthly Purchases by Channel')
plt.xlabel('Month')
plt.ylabel('Purchase Count')
plt.legend(title='Channel')
plt.xticks(rotation=0)
plt.grid(axis='y')
plt.tight_layout()
plt.show()

df['Purchase_Channel'].value_counts()

#Online purchase trends
online_data = df[df['Purchase_Channel'] == 'Online']
monthly_online = online_data.groupby('Purchase_Month').size()

plt.figure(figsize=(8, 5))
monthly_online.plot(kind='line', marker='o')
plt.title('Monthly Purchases - Online')
plt.xlabel('Month')
plt.ylabel('Number of Purchases')
plt.grid(True)
plt.tight_layout()
plt.show()

#Mix purchase trends
mixed_data = df[df['Purchase_Channel'] == 'Mixed']
monthly_mixed = mixed_data.groupby('Purchase_Month').size()

plt.figure(figsize=(8, 5))
monthly_mixed.plot(kind='line', marker='o', color='green')
plt.title('Monthly Purchases - Mixed')
plt.xlabel('Month')
plt.ylabel('Number of Purchases')
plt.grid(True)
plt.tight_layout()
plt.show()

#Instore purchse
instore_data = df[df['Purchase_Channel'] == 'In-Store']
instore_monthly = instore_data['Purchase_Month'].value_counts().sort_index()

plt.figure(figsize=(8, 5))
instore_monthly.plot(kind='line', marker='o')
plt.title('Monthly Purchases - In-Store')
plt.xlabel('Month')
plt.ylabel('Number of Purchases')
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6))
plt.plot(monthly_by_channel['Online'], marker='o', label='Online')
plt.plot(monthly_by_channel['Mixed'], marker='o', label='Mixed')
plt.plot(monthly_by_channel['In-Store'], marker='o', label='In-Store')

plt.title('Monthly Purchases by Channel')
plt.xlabel('Month')
plt.ylabel('Number of Purchases')
plt.legend(title='Channel')
plt.grid(True)
plt.tight_layout()
plt.show()



"""Across most months, the **Mixed channel consistently shows high activity, peaking in Month 9**, followed by Online and In-Store. Online purchases are relatively steady but tend to dip in months like 2 and 12. This suggests that **customers increasingly use multiple channels** to complete their purchases, highlighting the importance of a strong **omnichannel strategy**.

#b. Total Purchases per Channel

To evaluate the total number of purchases and total sales value across different channels, providing insights into which sales channels are most effective
"""

df['Purchase_Channel'].value_counts().plot(kind='bar', color='orange')
plt.title("Distribution channel")
plt.show()

channel_sales = df.groupby('Purchase_Channel')['Purchase_Amount'].sum().reset_index()
px.bar(channel_sales, x='Purchase_Channel', y='Purchase_Amount', title='Total sales perchannel')

"""# Product Favorites

The goal of this analysis is to identify which product categories perform best in terms of customer loyalty and return rate. This helps determine where customer satisfaction and retention are strongest
"""

category_stats = df.groupby('Purchase_Category')[['Brand_Loyalty', 'Return_Rate']].mean().sort_values('Brand_Loyalty', ascending=False)
category_stats.plot(kind='bar', figsize=(10,5))
plt.title('Average Brand Loyalty and Return Rate by Category')
plt.grid(True)
plt.tight_layout()
plt.show()

print("Most loyal category:", category_stats.index[0])
print("Category with lowest return rate:", category_stats['Return_Rate'].idxmin())

"""The insight reveals that **Office Supplies has the highest brand loyalty**, while **Health Care has the lowest return** rate both indicating strong customer trust and minimal dissatisfaction in these categories."""

# (profit) per region
region_profit = df.groupby('Location')['Purchase_Amount'].sum().sort_values(ascending=False).reset_index()

print("Region with the higest profit:")
print(region_profit.head())


plt.figure(figsize=(10,6))
sns.barplot(data=region_profit.head(10), x='Purchase_Amount', y='Location', palette='viridis')
plt.title('Top 10 Region ')
plt.xlabel('Total Purchase Amount (Proxy Profit)')
plt.ylabel('Region')
plt.tight_layout()
plt.show()

"""**Goteborg and Oslo are the top performing regions in terms of total purchase value**, indicating strong customer engagement and revenue potential.

#Product Loyalty or Return Rate

The goal of this analysis is to identify which product categories drive the most frequent repeat purchases, helping to prioritize areas for loyalty programs or bundling strategies.
"""

repeat_purchase = df.groupby('Purchase_Category')['Frequency_of_Purchase'].mean().sort_values(ascending=False)
ax = repeat_purchase.plot(kind='bar', figsize=(10,5), color='skyblue')
plt.title('Repeat Purchase Rate by Product Category')
plt.ylabel('Avg. Purchase Frequency')
plt.xticks(rotation=75)
plt.grid(True)

# Label bars
for p in ax.patches:
    height = p.get_height()
    ax.annotate(f'{height:.2f}', (p.get_x() + p.get_width() / 2., height),
                ha='center', va='bottom', fontsize=9, fontweight='bold')

plt.tight_layout()
plt.show()

print("Top category for repeat purchases:", repeat_purchase.idxmax())

"""The analysis shows that **Furniture leads in repeat purchases**, making it ideal for loyalty or bundling campaigns. **Other high-frequency categories like Beauty & Personal Care, Baby Products, and Toys & Games suggest strong customer habits**, suitable for auto-replenishment or subscription models. Mid-tier categories such as Books and Food & Beverages can benefit from seasonal promotions. Meanwhile, Jewelry & Accessories and Hotels have lower repeat rates,

#III)BEHAVIORSL PSYCHOLOGY

#Impulsive vs Planned Buyers
"""

df['Buyer_Type'] = df['Time_to_Decision'].apply(lambda x: 'Impulsive' if x <= 1 else 'Planned')


buyer_counts = df['Buyer_Type'].value_counts()
print(buyer_counts)

plt.figure(figsize=(6,4))
sns.countplot(data=df, x='Buyer_Type', palette='Set2')
plt.title('Impulsive vs Planned Buyers')
plt.xlabel('Type of Buyer')
plt.ylabel('Number of Customers')
plt.tight_layout()
plt.show()

"""Most customers tend to plan their purchases ahead of time, with only a small segment making impulsive buys. This suggests that marketing efforts should focus on nurturing these planned buyers, while also exploring strategies to encourage more spontaneous purchases. Balancing both approaches can help maximize overall sales.

#Average time to taken in purchasing

The goal is to understand how long customers take to make purchase decisions, helping to distinguish between impulsive and planned buyers
"""

plt.figure(figsize=(8, 5))
sns.histplot(df['Time_to_Decision'], bins=20, kde=True)
plt.title('Distribution of Purchase Decision Time')
plt.xlabel('Time to Decision (days)')
plt.ylabel('Number of Customers')
plt.grid(True)
plt.tight_layout()
plt.show()

print(f"Avg time to purchase: {df['Time_to_Decision'].mean():.2f} days")

"""On average, customers take approximately **8 days to make a purchase decision**, indicating that most are deliberative rather than impulsive buyers.

#Discount Sensitivity vs CLV
"""

df['Estimated_CLV'] = df['Frequency_of_Purchase'] * df['Purchase_Amount']

clv_by_discount = df.groupby('Discount_Used')['Estimated_CLV'].mean()
clv_by_discount.plot(kind='bar', color=['gray', 'green'])
plt.xticks([0, 1], ['No Discount', 'Used Discount'], rotation=0)
plt.ylabel('Average Estimated CLV')
plt.title('CLV by Discount Usage')
plt.grid(axis='y')
plt.tight_layout()
plt.show()

print(clv_by_discount)

"""The chart shows that customers who **used discounts have a slightly higher average CLV** (1930) compared to those who didn’t (1889). This suggests that discount strategies may help drive repeat purchases and spending, making them effective for boosting long-term customer value.

#Discount affecting purchase amount
"""

df['Discount_Used'].value_counts()

plt.figure(figsize=(8, 5))

sns.barplot(data=df, x='Discount_Used', y='Purchase_Amount', ci=None, palette='pastel')

plt.title('AVG purchase amount based Discount')
plt.xlabel('Engagement with using discount')
plt.ylabel('AVG Purchase Amount')
plt.tight_layout()
plt.show()

"""True = 521 customers used the discount

False = 479 customers did not use the discount
The use of discounts does not directly increase the average transaction value.

This indicates that customers who buy without discounts may be loyal segments or have high needs, so they continue shopping without waiting for discounts.

#Discount vs Loyalty
"""

sns.boxplot(data=df, x='Discount_Used', y='Brand_Loyalty')
plt.title("The Effect of Discounts on Brand Loyalty")
plt.show()

"""he boxplot shows **no significant difference in brand loyalty between customers who used discounts and those who didn’t**. This suggests that offering discounts does not harm loyalty, making it a viable strategy for boosting purchases without risking customer retention.

# ADVERTISEMENT ANALYSIS
"""

df['Engagement_with_Ads'].value_counts()

plt.figure(figsize=(8, 5))


sns.barplot(data=df, x='Engagement_with_Ads', y='Purchase_Amount', ci=None, palette='pastel')

plt.title('Average purchase amount based on Engagement factors')
plt.xlabel('Engagement with Ads')
plt.ylabel('AVG Purchase Amount')
plt.tight_layout()
plt.show()

"""The majority of customers (52.6%) have a high level of engagement with the ad, indicating that the campaign has succeeded in attracting attention. However, the other third are still at a medium to low level of engagement, which opens up opportunities for retargeting or more personalized content strategies.

#IV)CHANNEL & STRATEGY INSIGHTS

#Channel Preference Per Segment
"""

#segment data
channel_by_segment = df.groupby(['Segment', 'Purchase_Channel']).size().unstack()
#low
plt.figure(figsize=(5, 5))
channel_by_segment.loc['Low'].plot.pie(autopct='%1.1f%%', startangle=90, colors=plt.cm.Pastel1.colors)
plt.title('Channel Preference =Segment Low')
plt.ylabel('')
plt.tight_layout()
plt.show()

#Medium
plt.figure(figsize=(5, 5))
channel_by_segment.loc['Medium'].plot.pie(autopct='%1.1f%%', startangle=90, colors=plt.cm.Pastel1.colors)
plt.title('Channel Preference - Segment Medium')
plt.ylabel('')
plt.tight_layout()
plt.show()

#High
plt.figure(figsize=(5, 5))
channel_by_segment.loc['High'].plot.pie(autopct='%1.1f%%', startangle=90, colors=plt.cm.Pastel1.colors)
plt.title('Channel Preference =Segment High')
plt.ylabel('')
plt.tight_layout()
plt.show()

# Very High
plt.figure(figsize=(5, 5))
channel_by_segment.loc['Very High'].plot.pie(autopct='%1.1f%%', startangle=90, colors=plt.cm.Pastel1.colors)
plt.title('Channel Preference = Segment Very High')
plt.ylabel('')
plt.tight_layout()
plt.show()

"""The goal is to understand channel preferences across different customer segments. The chart shows that **Medium and High segments have the highest transaction volumes across all channels**, especially in the **Mixed channel**. Even the **Very High** segment, though smaller in size, shows balanced usage of all three channels.

#Product favorite per Segment
"""

segments = ['Low', 'Medium', 'High', 'Very High']

for seg in segments:
    plt.figure(figsize=(10, 5))
    subset = df[df['Segment'] == seg]
    sns.countplot(data=subset, x='Purchase_Category', order=subset['Purchase_Category'].value_counts().index, palette='pastel')
    plt.title(f'Purchase Category Distribution - Segment {seg}')
    plt.xlabel('Purchase Category')
    plt.ylabel('Number of Purchases')
    plt.xticks(rotation=90)
    plt.tight_layout()
    plt.show()

"""#Cross Purchase analysis"""

mobile_buyers = df[df['Purchase_Category'] == 'Mobile Accessories']['Customer_ID'].unique()
elec_buyers = df[(df['Customer_ID'].isin(mobile_buyers)) & (df['Purchase_Category'] == 'Electronics')]

print(f"Customers who purchased Mobile Accessories: {len(mobile_buyers)}")
print(f"Of them, also purchased Electronics: {elec_buyers['Customer_ID'].nunique()}")

#NANTIK CEK LAGI GMN KL KE SEMUAAAA

category_matrix = df.pivot_table(index='Customer_ID',
                                 columns='Purchase_Category',
                                 aggfunc='size',
                                 fill_value=0)


cross_purchase_matrix = category_matrix.T.dot(category_matrix)


np.fill_diagonal(cross_purchase_matrix.values, 0)

# Heatmap Cross Purchase
plt.figure(figsize=(10, 8))
sns.heatmap(cross_purchase_matrix, annot=True, fmt='g', cmap='YlGnBu')
plt.title("Cross Purchase Heatmap: Category vs Category")
plt.tight_layout()
plt.show()

"""Data hanya ada single purchase

#V) STRATEGIC INSIGHT

EXPORT DATA FOR DASHBOARD
"""

df.to_csv('cleaned_segmented_data.csv', index=False)


from google.colab import files
files.download('cleaned_segmented_data.csv')